%\documentclass[11pt,a4paper,titlepage]{article}
%\usepackage{xltxtra,fontspec,xunicode} 
%\usepackage[slantfont,boldfont]{xeCJK} % 允许斜体和粗体 
%\setCJKmainfont{AR PL SungtiL GB} % 设置缺省中文字体 
%\setmainfont{SimSun}

\documentclass[11pt]{article}
\usepackage[BoldFont,SlantFont,CJKchecksingle]{xeCJK}
\setCJKmainfont[BoldFont=SimHei]{SimSun}
\setCJKmonofont{SimSun}% 设置缺省中文字体
\parindent 2em   %段首缩进
 
\begin{document}
\title{\bf操作系统Lab1实验报告\rm}
\author{\bf111220174 张赫\rm}
\date{\bf 2013年5月22日 \rm}

\maketitle


\section{实验内容}
\begin{enumerate}
  \item 实现printk函数。
 \item 实现内核线程管理相关的函数和线程调度。
\end{enumerate}


\section{实验目标}
\begin{enumerate}
  \item 加深对指针的认识。
  
  \item 了解线程结构和如何切换。
  
  \item 了解线程锁和调试方法。
\end{enumerate}

\section{额外知识}
\begin{enumerate}
 \item 
  《深入分析Linux内核源码》让我了解了关于进程结构和调度的基本知识。
 \item
  i386手册让我查到了可靠的中断号含义和关于进程的深层知识。
\end{enumerate}
\section{实验设计}
\begin{enumerate}
  \item
    第一个printk函数的实现并不困难，而且最难的一行代码已经被给出，其它的只要想清楚指针即可。
   \item
     线程或进程的切换是中断驱动的堆栈切换。在中断的处理函数中加入处理线程切换的代码，整个过程应该在关中断中进行。
     为了保证程序的可扩展性以及对没有malloc函数的折中，pcb最开始用数组分配但用链表组织，因为线程比较少不单独设运行队列，线程运行状态用enum State表示。
     正如在slides里所说，切换进程的时候保存现在的trapframe再换一个新的current即可。最重要的是最后movl newesp R[esp]的代码应该写在汇编里！
    \item
      在创建线程的时候trapframe的初始值大部分按照slides中所说的设置，eip则直接为(uint32\_t)entry，为了方便调试为每个线程增加了pid，为了保证运行顺序，每个新建立的进程都加在第一个线程之前也就是队列的最后。
    \item
      每个线程的PCB中包含lock\_count计数该进程的lock以解决lock嵌套和睡眠问题。在睡眠前解锁并手动触发软中断切换进程避免忙等。在PV操作中的两端使用lock以保证其原子性。
    \item
      为了保证中断的正确性，在几乎每句代码后面加上检验IF的assert，并大量跑数据以保证其正确性。
\end{enumerate}

\section{实现方法}
\begin{enumerate}
   \item
      在printk处理单个字母的时候直接将其转化为int型然后直接输出。
    \item
      在设置中断的时候延续lab0的方法用句柄传递中断处理函数以增加可扩展性。
   \item
      利用list\_entry()这个看上去很奇怪的函数可以很方便地使用List, 这个函数和list\_foreach()函数以及链表基本操作构成了链表部分。因为没有用多个队列，所以运行队列不涉及删除等操作。
   \item
      为了防止在第一次调度的时候出现错误，在初始化的时候将current\_pcb = NULL并调度的时候写了一个分支判断是不是第一次调度。
    \item
      大部分代码比如PV操作，测试程序的生产者和消费者部分除了添加lock \& unlock外和课程网站上一样，避免unlock错误的方法是在每个pcb设lock\_count。
    \item
      适当地做了一些细节隐藏，比如int \$0x80这种汇编代码并适当把一些函数声名为static inline，一些变量声明为static。
      为了让线程控制部分的聚合度增大，新增加thread.c, thread.h集中实现和线程有关的函数。
\end{enumerate}
 
\section{困难与解决方案}
\begin{enumerate}
  \item
    在解决思考问题的时候无法用gdb进入init\_kvm进行调试，看了汇编代码后想到break function只是停在fucntion的地址，然而这时虚拟内存还未开始，所以应该手动停在相应代码的物理内存。另外，单步汇编命令执行是神器。
  \item
    最开始想在c语言中插入汇编代码以在中断恢复程序中改变R[esp]，但这样运行的时候一直都有14号中断。
    在查了386手册和繁复的调试后发现如果在c语言中插入，在所调用的函数返回的时候esp必然被改变，这样在汇编部分将无法正确还原原来的寄存器现场。
    所以只能在汇编中extern current然后改变esp。
  \item
    一开始在创建线程的时候总是考虑没有线程创立就中断的问题，所以写了一些分支语句来修正这个问题，但是没有很好地将其解决。
    过了很久我才发现如果先来中断而使某个pcb所代表的线程开始运行，那么后面创建线程的语句永远不会执行，遂在所有线程创建完成之后才打开中断也就没有这个问题了。
  \item
    虽然在程序中加了很多INTR 和 assert，但还是有漏掉的地方。这个问题很幸运地被一个assert发现了，这个assert是断言调度程序返回的pcb一定是可运行的。
    虽然这个断言没让我直接找到错误的地方，但是如果没有这个断言估计好花更长时间才能找到错误。
    于是加入超级多的print以及assert(在提交的代码中仅注释掉了）然后分析出错地方的log才找到有问题的地方：
    在睡眠的地方本来应该先改变pcb->state再unlock然后int 0x80, 但我将unlock写在了sleep()函数前面(sleep()包含改变state和int 0x80)，导致最终所有线程都不处于执行状态。
  \item
    还有一个未解决的问题，这个问题也发生在其他几位同学的身上。最终的程序在-O2下放着不动一直跑的情况下不会出错，但是如果切换到其他工作区做其他事就会有问题。
    如果鼠标陷入虚拟机有一定几率出现13号中断，如果没有则乱晃工作区有一定几率会造成整个电脑操作系统的崩溃。如果出现中断是程序的问题，整个电脑操作系统的崩溃就不应该是我自己程序的问题了。
 \end{enumerate}

    
\section{总结}
    这次实验总共花了两周，这两周的间隔大概有1个月。第一周写完了思考题，第二周写完了线程部分的程序。
    每个部分的所消耗的时间虽然相同，但是感觉完全不一样。第一部分基本都在查各种书和思考内存映射的事，第二部分基本都在调试。理论实践双丰收。
    虽然这次的实验代码量仍然比较小，但是思考和学习到的东西很多，对虚拟内存、最底层的进程线程切换和线程锁有了非常深入的了解，相信这对以后的多线程编程打下了坚实的基础。
    
    
\section{致谢}
    感谢写《深入分析Linux内核源码》的大姐。这本书是很好的基础知识介绍（仅相对于手册是基础知识）。
    
    不过当然，最要感谢的还是\bf JYY \rm 大大了！！！


\section{思考题}
\begin{enumerate}
	\item \bf
启动分页。main.c中的entry函数是整个操作系统代码的入口点。entry所执行的第一件事就是init\_kvm，创建内核页表并且启动分页。注意到我们在链接内核时使用的编译选项：
\$(LD) \$(LDFLAGS) -e entry -Ttext 0xC0100000 -o kernel \$(OBJS)
内核“认为”它处于内存的0xc0100000位置，但是我们在载入时，却是将内核载入到物理内存的0x100000位置。在正确的页表建立以前，任意对0xc0100000附近地址的访问都将引起非预期的结果。实际上，编写bootloader和init\_kvm时都应当非常小心地处理虚拟地址和物理地址。请仔细阅读bootloader和init\_kvm的代码，结合objdump的结果，解释内核启动分页的过程。此外，为什么kernel在分页未启动时，试图用虚拟内存地址访问，但却不会产生任何错误？ \rm

答：首先，我们应该注意这种虚拟内存的映射方式仅仅是内核的映射，而不是用户区的映射。
内核有1G的空间，在每个进程的虚拟内存中都有这1G的空间并共享这些空间。这些空间根据KOFFSET线性映射将物理内存最开始的地方映射到0xC ...的地方，也即每个进程空间的最后1G。
因为内核映射的需要，于是不得不在-Ttext的时候写0xC0100000，这样一来在建立好虚拟内存后一切可以正常运行。

Gcc编译出的代码是按照虚拟内存建立的符号表，所以在LD的时候应该连接虚拟地址。
然而在未实现分页之前，所有的操作都是物理地址，所以要将内核载入到0x100000。同时，做为物理内存来说，内核本身就该在最开始的地方。
我们注意到，在bootmain 和 init\_kvm中，所有的地址操作都将编译器编出来的虚拟
地址转化成了物理地址进行操作，这是因为这时的cr0寄存器的最高位为0,没有启动分页，所有操作都是对物理地址进行操作，也就是说如果不转化，操作的地址在物理意义上是一个本该属于用户区的地址。
但是这么做并不会妨碍程序的正常运行，只是在启动分页后内核的代码将被其他用户进程的代码覆盖而彻底死机。
同样，这个时候访问0xC0100000地方理论上是可以的，虽然是直接访问物理地址，但在此时什么都没有的情况下不会造成错误。只不过这部分内存被改写后，如果用户程序再用到这块区域而且没有检查初始值就会造成问题，因为编译器根本没有想到这块内存会有问题而将默认为0的数据放在这里，比如字符串，这无疑会引起不必要的麻烦。

下面说一下具体的分页过程。kptab中存放的是每个页的物理地址，最后两位为权限位; kpdir中存放的是每个页目录起始点的页的物理地址，最后两位为权限位。因为此时操作的是物理地址，所以都转换为物理地址。
首先进行分页，间隔为PG\_SIZE,每页初始的地方连带标志位放在页表中（因为页表事实上只需要10位）。然后用memset分配零页目录。
下一步即分页目录，原理和分页相同，将每组页表的第一个页表地址装入页目录，只不过因为硬件需要所以在相对应的虚拟地址再建立一个对页表的索引。
最后设置cr3为页目录起始并且将cr0的最高位设位1启动分页。


\item  \bf
理解volatile。在main.c中有一段难以理解的代码：
init\_kvm();

void(*volatile next)(void) = os\_init;

asm volatile("addl \%0, \%\%esp" : : ""(KOFFSET));

next();

panic("init code should never return");

细心的你会发现，即便将volatile关键字删除，我们的程序仍然能够平稳正确的运行。然而，这里的volatile却是不能忽略的。当我们创建ring3的用户进程以不同的内存映射访问时，删除volatile将会引起整个操作系统的崩溃。

请使用objdump工具比较在有和没有volatile关键字时生成汇编代码的细微区别，并解释为什么现在代码运行得很好，但是在位于内存低位的页表映射改变时，为什么会发生问题。\rm

答：首先需要指出，在-O0的情况下，这两种代码不会有任何区别，只有当用-O2选项的时候才会产生区别。
区别在于没加volatile的代码不会有那一句汇编，后面调用next()的时候将直接call(*\%eax)；另一种则call(next)。
因为此时操作系统已经启动了虚拟内存，所以如果直接\%eax的话在变换了虚拟内存映射方式的时候\%eax便不再映射到函数在该虚拟内存下的地址，于是无法继续运行。
而先将volatile next=\&function则会消除这个问题，next的值本身就是函数的位置，即使改变内存映射方式也可以找到函数。
事实上，如果call是绝对地址调用也不会出现问题，问题在于call会被翻译成e8也就变成了相对地址调用，这样一来如果在此之前改变低位内存页表映射就会造成问题了。
\end{enumerate}    

\end{document}
